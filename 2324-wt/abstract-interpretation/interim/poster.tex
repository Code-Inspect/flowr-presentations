\makeatletter
\newcommand\input@path{{smile},{flowr-logo}}
\makeatother

\documentclass[color,coloraccent=red!60!black,listings]{poster}

\usepackage[notext,color=accent]{flowrlogo}
\usepackage{lipsum}
\usepackage[normalem]{ulem}
\usepackage[verbatim]{lstfiracode}
\usepackage[notext,nott,nosf,nomath]{kpfonts-otf}

\title{Abstract Interpretation}
\subtitle{The cooler AI}
\author{Lukas Pietzschmann, Florian Sihler}
\uni{Ulm University}
\institute{Institute of Software Engineering and Programming Languages}
\date{02/02/2024}
\logo{logos/splogo.png}

\columnseprule0pt
\def\ULthickness{.7pt}

\def\flowr{\textit{flowR}}

\makeatletter
\lstdefinestyle{firastyleb}{style=FiraCodeStyle,style=smile@lst@base}
\lstdefinestyle{firastylep}{style=FiraCodeStyle,style=smile@lst@plain}
\makeatother
\lstset{tabsize=4,style=firastyleb}

\def\rc#1{\lstinline[language=r]{#1}}

\newsavebox\flowrlogob
\savebox\flowrlogob{\flowrlogo}
\def\uselogo#1{\scalebox{#1}{\usebox\flowrlogob}}
\begin{document}
\tikzset{logo/.append style={fill opacity=0.85}}
\begin{tikzpicture}[remember picture, overlay]
	\node[shift={(-18mm,-18mm)},node on layer=background] at (current page.north east) {\uselogo{13}};
\end{tikzpicture}
\maketitle

\begingroup
\makeatletter
\smile@linewidth1px
\tikzset{
	n/.style={minimum width=7mm,minimum height=7mm,shadow},
	a/.style={arrow,short=1mm},
	no/.style={opacity=0.3,no shadows},
	t/.style={roundednode,dashed,node on layer=background,inner sep=2mm,fill=lightgray!20,fill opacity=0.85,minimum width=\columnwidth,minimum height=4.2cm},
	dr/.style={pill},
	ds/.style={pill,shift={(1mm,1mm)}},
	label/.style={line join=round,chamfered rectangle,chamfered rectangle xsep=2pt,lw,inner sep=2pt,draw=black,fill=white},
	node distance=6mm
}
\begin{multicols}{3}
	\def\i#1{\color{gray!50!black}\textsubscript{#1}}
	\def\j#1{\rlap{\i{#1}}}
	\newsavebox\exampleb
	\begin{lrbox}\exampleb
	\begin{lstlisting}[language=R,style=firastylep]
x§\j1§ <- 10
y§\j1§ <- 5 + x§\i2§
if(y§\j2§ > 10) {
	compA(y§\i3§)
} else {
	compB(y§\i4§)
}
	\end{lstlisting}
	\end{lrbox}
	\begin{tikzpicture}
		\node (L) {\usebox\exampleb};
		\node[t,fit=(L)] (F) {};
		% \node[label] at (F.south) {Step 1};
	\end{tikzpicture}\par
	\paragraph{Step 1} To set everything up, we take in the code, get its abstract
	syntax tree, normalize it, and finally build and return the dataflow graph. This
	graph can then be used as a base for the next step.\par
	\columnbreak
	\begin{tikzpicture}
		\node[n,roundednode] (X1) {\rc{x}\textsubscript1};
		\node[n,roundnode,right=of X1] (X2) {\rc{x}\textsubscript2};
		\node[n,roundednode,right=of X2] (Y1) {\rc{y}\textsubscript1};
		\node[n,roundnode,right=of Y1] (Y2) {\rc{y}\textsubscript3};
		\node[n,squarenode,right=of Y2] (C1) {\rc{compA}};

		\node[n,roundnode,below=of Y2] (Y3) {\rc{y}\textsubscript4};
		\node[n,squarenode,below=of C1] (C2) {\rc{compB}};

		\node[n,roundnode,above=of Y1] (Y4) {\rc{y}\textsubscript2};

		\node[dr] at (X1.north east) {\tiny$\{10\}$};
		\node[ds] at (X2.north east) {\tiny$\{10\}$};
		\node[dr] at (Y1.north east) {\tiny$\{15\}$};
		\node[ds] at (Y2.north east) {\tiny$\{15\}$};
		\node[ds] at (Y3.north east) {\tiny{\setmathfont{KpMath}$\bot$}};
		\node[ds] at (Y4.north east) {\tiny$\{15\}$};

		\node[t,fit=(X1)(X2)(Y1)(Y2)(Y3)(Y4)(C1)(C2)] (F) {};
		% \node[label] at (F.south) {Step 2};

		\draw[a] (X1) to (X2);
		\draw[a] (X2) to (Y1);
		\draw[a] (Y1) to (Y2);
		\draw[a] (Y2) to (C1);

		\draw[a] (Y1) to (Y3);
		\draw[a] (Y3) to (C2);

		\draw[a] (Y1) to (Y4);
	\end{tikzpicture}\par
	\paragraph{Step 2} In the second step happens the actual abstract interpretation.
	This step will gradually decorate the dataflow graph with the domains of the
	respective variables.\par
	\columnbreak
	\begin{tikzpicture}
		\node[n,roundednode] (X1) {\rc{x}\textsubscript1};
		\node[n,roundnode,right=of X1] (X2) {\rc{x}\textsubscript2};
		\node[n,roundednode,right=of X2] (Y1) {\rc{y}\textsubscript1};
		\node[n,roundnode,right=of Y1] (Y2) {\rc{y}\textsubscript3};
		\node[n,squarenode,right=of Y2] (C1) {\rc{compA}};

		\begin{scope}[no,transparency group]
			\node[n,roundnode,below=of Y2] (Y3) {\rc{y}\textsubscript4};
			\node[n,squarenode,below=of C1] (C2) {\rc{compB}};
			\node[ds] at (Y3.north east) {\tiny{\setmathfont{KpMath}$\bot$}};
		\end{scope}

		\node[n,roundnode,above=of Y1] (Y4) {\rc{y}\textsubscript2};

		\node[dr] at (X1.north east) {\tiny$\{10\}$};
		\node[ds] at (X2.north east) {\tiny$\{10\}$};
		\node[dr] at (Y1.north east) {\tiny$\{15\}$};
		\node[ds] at (Y2.north east) {\tiny$\{15\}$};
		\node[ds] at (Y4.north east) {\tiny$\{15\}$};

		\node[t,fit=(X1)(X2)(Y1)(Y2)(Y3)(Y4)(C1)(C2)] (F) {};
		% \node[label] at (F.south) {Step 3};

		\draw[a] (X1) to (X2);
		\draw[a] (X2) to (Y1);
		\draw[a] (Y1) to (Y2);
		\draw[a] (Y2) to (C1);

		\begin{scope}[no,transparency group]
			\draw[a] (Y1) to (Y3);
			\draw[a] (Y3) to (C2);
		\end{scope}

		\draw[a] (Y1) to (Y4);
	\end{tikzpicture}\par
	% \paragraph{Step 3} The last step uses the decorated dataflow graph to determine wich
	% path can never be executed. The identified path will then be discarded from the
	% graph.\par
	\paragraph{Step 3} The last step uses the decorated dataflow graph to determine and
	track different properties. We can, e.g., catch endless loops, or, as shown above,
	eliminate dead paths in the dataflow graph.\par
\end{multicols}\bigskip
\endgroup

\begin{multicols}{3}
	\begin{minipage}{\dimexpr2\columnwidth+\columnsep\relax}
		\section*{How abstract interpretation fits into \flowr}
		\paragraph{\flowr}\flowr{} is a static \emph{dataflow analyzer} and
		\emph{program slicer} for the R language. Program slicers reduce a given program
		to a set of statements --- the so called slices --- that influence a variable at
		a specific point in the program --- the slicing criterion. \flowr{} formulates
		the slicing as a reachability problem on the dataflow graph, which itself is
		based on the abstract syntax tree of the given R~program.
		\paragraph{Abstract Interpretation} Abstract interpretation is all about
		figuring out \emph{runtime properties} of a given program without actually
		executing it. These properties include aspects like the sign or nullness of a
		variable. For now we decided to limit ourselves to determining the \emph{domain
		of numeric variables}. In other words, we want to know what values a variable
		can have at a certain point in the program.
		\paragraph{Abstract interpretation in \flowr} Abstract interpretation helps
		\flowr{} to further \emph{narrow down the slice} of a program. This can be done
		by removing certain paths from the dataflow graph if we can prove that they will
		never be executed. Imagine a conditional like \rc{if(i < 10) doit() else run()}.
		If, through abstract interpretation, we know that \rc{i} is always smaller than
		\rc{10}, there's no need to include the path stemming from the \rc{if}'s
		else-case in the slice. % TODO: is this okay? Or does it read like we only catch dead code
		\section*{Abstract Interpretation}
		\begin{tikzpicture}
			\node[roundednode,minimum width=\textwidth,minimum height=0.2\textheight,draw=black,fill=lightgray!20] {\Large Maybe an example?!};
		\end{tikzpicture}
		\lipsum[1-2]
	\end{minipage}\vfill\columnbreak\null\columnbreak
	\section*{Project Organization}
	\paragraph{Organization} We're doing \emph{weekly meetings}, where we discuss the
	progress made in the past week, talk about open issues, and prioritize tasks for the
	next week. We also keep a \emph{record of important things} that came up in our
	meeting. If there's any spare time, Florian often tells me about new
	\sout{weird}cool things he learned about the R language.
	\paragraph{Tech Stack} \flowr{} is developed with \emph{TypeScript}, then compiled
	down to JavaScript with Node.js as its runtime. While we use different libraries for
	utilitarian tasks --- like chai for assertions, mocha for tests, or tslog for
	logging --- all major functionalities are implemented \emph{by hand}. This includes
	the abstract interpretation itself.
	\paragraph{QA} To ensure the employment of best practices, we always do \emph{code
	reviews} on pull requests. This massively helps with keeping the code easy to
	understand and well readable.\par
	If an error slips through during the review, rest assured that one of \flowr's
	extensive suite of over \emph{1000 tests} will certainly catch it. Additionally, we
	consistently introduce new tests promptly whenever there is new code in the
	project.\par
	We also make heavy use of \emph{assertions} --- or how we call them:~guards ---
	whenever possible to make sure our mental model aligns with the actual execution of
	the code.
	\paragraph{Documentation} \flowr's documentation is split into two parts:
	\begin{enumerate*}
		\item a \emph{user facing} documentation hosted in a GitHub wiki and
		\item a \emph{developer facing} documentation built from inline comments
	\end{enumerate*}. % TODO more on docs
	\section*{Future Work}
	\lipsum[2]
\end{multicols}
\end{document}